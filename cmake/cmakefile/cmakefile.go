// Package cmakefile contains code to generate a CMake file
package cmakefile

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/apex/log"
	"github.com/measurement-kit/mkbuild/cmake/cmakefile/prebuilt"
	"github.com/measurement-kit/mkbuild/cmake/cmakefile/restrictiveflags"
)

// CMakeFile is a CMakeListst.txt file
type CMakeFile struct {
	// output contains the CMakeLists.txt lines
	output strings.Builder

	// indent is the indent string to prefix to each line
	indent string
}

// WithIndent runs |func| with the specified |indent|.
func (cmake *CMakeFile) WithIndent(indent string, fn func()) {
	oldIndent := cmake.indent
	cmake.indent += indent
	fn()
	cmake.indent = oldIndent
}

// writeSectionComment writes a comment for |name| in |cmake|.
func (cmake *CMakeFile) writeSectionComment(name string) {
	cmake.writeEmptyLine()
	cmake.WriteLine(fmt.Sprintf("#"))
	cmake.WriteLine(fmt.Sprintf("# %s", name))
	cmake.WriteLine(fmt.Sprintf("#"))
	cmake.writeEmptyLine()
}

// writeEmptyLine writes an empty line to output.
func (cmake *CMakeFile) writeEmptyLine() {
	cmake.WriteLine("")
}

// WriteLine writes a line to the CMakeLists.txt file.
func (cmake *CMakeFile) WriteLine(s string) {
	if s != "" {
		_, err := cmake.output.WriteString(cmake.indent)
		if err != nil {
			log.WithError(err).Fatal("cannot write indent")
		}
		_, err = cmake.output.WriteString(s)
		if err != nil {
			log.WithError(err).Fatal("cannot write string")
		}
	}
	_, err := cmake.output.WriteString("\n")
	if err != nil {
		log.WithError(err).Fatal("cannot write newline")
	}
}

// Open opens a CMake project named |name|.
func Open(name string) *CMakeFile {
	cmake := &CMakeFile{}
	cmake.WriteLine("# Autogenerated by `mkbuild`; DO NOT EDIT!")
	cmake.writeEmptyLine()
	cmake.WriteLine(fmt.Sprintf("cmake_minimum_required(VERSION 3.12.0)"))
	cmake.WriteLine(fmt.Sprintf("project(\"%s\")", name))
	cmake.writeEmptyLine()
	cmake.WriteLine("include(CheckIncludeFileCXX)")
	cmake.WriteLine("include(CheckLibraryExists)")
	cmake.WriteLine("include(CheckCXXCompilerFlag)")
	cmake.writeEmptyLine()
	cmake.WriteLine("set(THREADS_PREFER_PTHREAD_FLAG ON)")
	cmake.WriteLine("find_package(Threads REQUIRED)")
	cmake.writeEmptyLine()
	cmake.WriteLine("set(CMAKE_POSITION_INDEPENDENT_CODE ON)")
	cmake.WriteLine("set(CMAKE_CXX_STANDARD 11)")
	cmake.WriteLine("set(CMAKE_CXX_STANDARD_REQUIRED ON)")
	cmake.WriteLine("set(CMAKE_CXX_EXTENSIONS OFF)")
	cmake.WriteLine("set(CMAKE_C_STANDARD 11)")
	cmake.WriteLine("set(CMAKE_C_STANDARD_REQUIRED ON)")
	cmake.WriteLine("set(CMAKE_C_EXTENSIONS OFF)")
	cmake.writeEmptyLine()
	cmake.WriteLine("list(APPEND CMAKE_REQUIRED_LIBRARIES Threads::Threads)")
	cmake.IfWIN32(func() {
		cmake.WriteLine("list(APPEND CMAKE_REQUIRED_LIBRARIES ws2_32 crypt32)")
	}, nil)
	cmake.writeEmptyLine()
	cmake.WriteLine("enable_testing()")
	cmake.IfWIN32(func() {
		cmake.if32bit(func() {
			cmake.WriteLine("SET(MK_WIN32_ARCH \"x86\")")
		}, func() {
			cmake.WriteLine("SET(MK_WIN32_ARCH \"x64\")")
		})
	}, nil)
	// Apparently the following flags are now required on macOS to link
	// with software compiled using Homebrew. Annoying.
	cmake.WriteLine(`if((${APPLE}))`)
	cmake.WriteLine(`  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -I/usr/local/include")`)
	cmake.WriteLine(`  set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -L/usr/local/lib")`)
	cmake.WriteLine(`  set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -L/usr/local/lib")`)
	cmake.WriteLine(`endif()`)
	cmake.writeEmptyLine()
	cmake.WriteLine(`include(CheckFunctionExists)`)
	cmake.WriteLine(`include(CheckSymbolExists)`)
	return cmake
}

// download downloads |URL| to |filename| and checks the |SHA256|.
func (cmake *CMakeFile) download(filename, SHA256, URL string) {
	cmake.WriteLine(fmt.Sprintf("message(STATUS \"download: %s\")", URL))
	cmake.WriteLine(fmt.Sprintf("file(DOWNLOAD %s", URL))
	cmake.WriteLine(fmt.Sprintf("  \"%s\"", filename))
	cmake.WriteLine(fmt.Sprintf("  EXPECTED_HASH SHA256=%s", SHA256))
	cmake.WriteLine(fmt.Sprintf("  TLS_VERIFY ON)"))
}

// checkCommandError writes the code to check for errors after a
// command has been executed.
func (cmake *CMakeFile) checkCommandError(variable string) {
	cmake.WriteLine(fmt.Sprintf("if(\"${%s}\")", variable))
	cmake.WriteLine(fmt.Sprintf("  message(FATAL_ERROR \"${%s}\")", variable))
	cmake.WriteLine(fmt.Sprintf("endif()"))
}

// mkdirAll creates |destdirs|.
func (cmake *CMakeFile) mkdirAll(destdirs string) {
	cmake.WriteLine(fmt.Sprintf("message(STATUS \"mkdirAll: %s\")", destdirs))
	cmake.WriteLine(fmt.Sprintf("execute_process(COMMAND"))
	cmake.WriteLine(fmt.Sprintf(
		"  ${CMAKE_COMMAND} -E make_directory \"%s\"", destdirs,
	))
	variable := fmt.Sprintf("FAILURE_%d", cmake.output.Len())
	cmake.WriteLine(fmt.Sprintf("  RESULT_VARIABLE %s)", variable))
	cmake.checkCommandError(variable)
}

// unzip extracts |filename| in |destdir|.
func (cmake *CMakeFile) unzip(filename, destdir string) {
	cmake.WriteLine(fmt.Sprintf("message(STATUS \"Extract: %s\")", filename))
	cmake.WriteLine(fmt.Sprintf("execute_process(COMMAND"))
	cmake.WriteLine(fmt.Sprintf(
		"  ${CMAKE_COMMAND} -E tar xf \"%s\"", filename,
	))
	cmake.WriteLine(fmt.Sprintf("  WORKING_DIRECTORY \"%s\"", destdir))
	variable := fmt.Sprintf("FAILURE_%d", cmake.output.Len())
	cmake.WriteLine(fmt.Sprintf("  RESULT_VARIABLE %s)", variable))
	cmake.checkCommandError(variable)
}

// untar extracts |filename| in |destdir|.
func (cmake *CMakeFile) untar(filename, destdir string) {
	cmake.unzip(filename, destdir)
}

// CheckFunctionExists checks whether |name| is a function and
// defines the |define| preprocessor macro in such case.
func (cmake *CMakeFile) CheckFunctionExists(name, define string) {
	cmake.WriteLine(fmt.Sprintf("check_function_exists(%s %s)", name, define))
	cmake.WriteLine(fmt.Sprintf("if(${%s})", define))
	cmake.WithIndent("  ", func() {
		cmake.WriteLine(fmt.Sprintf("add_definitions(-D%s)", define))
	})
	cmake.WriteLine("endif()")
}

// CheckSymbolExists checks whether |name| is a symbol in |header| and
// defines the |define| preprocessor macro in such case.
func (cmake *CMakeFile) CheckSymbolExists(name, header, define string) {
	cmake.WriteLine(fmt.Sprintf(
		"check_symbol_exists(%s %s %s)", name, header, define,
	))
	cmake.WriteLine(fmt.Sprintf("if(${%s})", define))
	cmake.WithIndent("  ", func() {
		cmake.WriteLine(fmt.Sprintf("add_definitions(-D%s)", define))
	})
	cmake.WriteLine("endif()")
}

// AddRequiredDefinition adds |definition| to the macro definitions
func (cmake *CMakeFile) AddRequiredDefinition(definition string) {
	cmake.WriteLine(fmt.Sprintf(
		"LIST(APPEND CMAKE_REQUIRED_DEFINITIONS %s)", definition,
	))
}

// AddRequiredIncludeDir adds |path| to the header search path
func (cmake *CMakeFile) AddRequiredIncludeDir(path string) {
	cmake.WriteLine(fmt.Sprintf(
		"LIST(APPEND CMAKE_REQUIRED_INCLUDES \"%s\")", path,
	))
}

// AddRequiredLibrary adds |library| to the libraries to link with
func (cmake *CMakeFile) AddRequiredLibrary(library string) {
	cmake.WriteLine(fmt.Sprintf(
		"LIST(APPEND CMAKE_REQUIRED_LIBRARIES \"%s\")", library,
	))
}

// checkPlatformCheckResult writes code to deal with a platform check result.
func (cmake *CMakeFile) checkPlatformCheckResult(item, variable string) {
	cmake.WriteLine(fmt.Sprintf("if(NOT (\"${%s}\"))", variable))
	cmake.WriteLine(fmt.Sprintf(
		"  message(FATAL_ERROR \"cannot find: %s\")", item,
	))
	cmake.WriteLine(fmt.Sprintf("endif()"))
}

// RequireHeaderExists requires that |header| exists.
func (cmake *CMakeFile) RequireHeaderExists(header string) {
	variable := fmt.Sprintf("MK_HAVE_HEADER_%d", cmake.output.Len())
	cmake.WriteLine(fmt.Sprintf(
		"CHECK_INCLUDE_FILE_CXX(\"%s\" %s)", header, variable,
	))
	cmake.checkPlatformCheckResult(header, variable)
}

// RequireLibraryExists requires that |function| exists in |library|.
func (cmake *CMakeFile) RequireLibraryExists(library, function string) {
	variable := fmt.Sprintf("MK_HAVE_LIB_%d", cmake.output.Len())
	cmake.WriteLine(fmt.Sprintf(
		"CHECK_LIBRARY_EXISTS(\"%s\" \"%s\" \"\" %s)", library, function, variable,
	))
	cmake.checkPlatformCheckResult(library, variable)
}

// setRestrictiveCompilerFlags sets restrictive compiler flags.
func (cmake *CMakeFile) setRestrictiveCompilerFlags() {
	cmake.writeSectionComment("Set restrictive compiler flags")
	cmake.output.WriteString(restrictiveflags.S)
	cmake.writeEmptyLine()
	cmake.WriteLine(fmt.Sprintf("MKSetRestrictiveCompilerFlags()"))
}

// prepareForCompilingTargets prepares internal variables such that
// we can compile targets with the required compiler flags.
func (cmake *CMakeFile) prepareForCompilingTargets() {
	cmake.writeSectionComment("Prepare for compiling targets")
	cmake.WriteLine("add_definitions(${CMAKE_REQUIRED_DEFINITIONS})")
	cmake.WriteLine("include_directories(${CMAKE_REQUIRED_INCLUDES})")
}

// targetLinkLibraries will write the required libraries for target.
func (cmake *CMakeFile) targetLinkLibraries(name string, libs []string) {
	cmake.WriteLine(fmt.Sprintf("target_link_libraries("))
	cmake.WriteLine(fmt.Sprintf("  %s", name))
	for _, lib := range libs {
		cmake.WriteLine(fmt.Sprintf("  %s", lib))
	}
	cmake.WriteLine(fmt.Sprintf("  ${CMAKE_REQUIRED_LIBRARIES}"))
	cmake.WriteLine(fmt.Sprintf(")"))
}

// AddExecutable defines an executable to be compiled.
func (cmake *CMakeFile) AddExecutable(
	name string, sources []string, libs []string, install bool,
) {
	cmake.writeSectionComment(name)
	cmake.WriteLine(fmt.Sprintf("add_executable("))
	cmake.WriteLine(fmt.Sprintf("  %s", name))
	for _, source := range sources {
		cmake.WriteLine(fmt.Sprintf("  %s", source))
	}
	cmake.WriteLine(fmt.Sprintf(")"))
	cmake.targetLinkLibraries(name, libs)
	if install {
		cmake.WriteLine(fmt.Sprintf("install(TARGETS %s DESTINATION bin)", name))
	}
}

// AddLibrary defines a library to be compiled.
func (cmake *CMakeFile) AddLibrary(
	name string, sources []string, libs []string, install bool,
	headers []string,
) {
	cmake.writeSectionComment(name)
	if sources != nil {
		cmake.WriteLine(fmt.Sprintf("add_library("))
		cmake.WriteLine(fmt.Sprintf("  %s", name))
		for _, source := range sources {
			cmake.WriteLine(fmt.Sprintf("  %s", source))
		}
		cmake.WriteLine(fmt.Sprintf(")"))
		cmake.targetLinkLibraries(name, libs)
		if install {
			cmake.WriteLine(fmt.Sprintf("install(TARGETS %s DESTINATION lib)", name))
		}
	}
	if headers != nil && install {
		cmake.WriteLine(fmt.Sprintf("install("))
		cmake.WriteLine(fmt.Sprintf("  FILES"))
		for _, header := range headers {
			cmake.WriteLine(fmt.Sprintf("  %s", header))
		}
		cmake.WriteLine(fmt.Sprintf("  DESTINATION include"))
		cmake.WriteLine(fmt.Sprintf(")"))
	}
}

// AddScript defines a script to be installed.
func (cmake *CMakeFile) AddScript(name string, install bool) {
	if install {
		cmake.writeSectionComment(name)
		cmake.WriteLine(fmt.Sprintf("install("))
		cmake.WriteLine(fmt.Sprintf("  PROGRAMS"))
		cmake.WriteLine(fmt.Sprintf("  %s", name))
		cmake.WriteLine(fmt.Sprintf("  DESTINATION bin"))
		cmake.WriteLine(fmt.Sprintf(")"))
	}
}

// RunTest defines a test to be run
func (cmake *CMakeFile) AddTest(name, command string) {
	cmake.writeSectionComment("test: " + name)
	cmake.WriteLine(fmt.Sprintf("add_test("))
	cmake.WriteLine(fmt.Sprintf("  NAME %s COMMAND %s", name, command))
	cmake.WriteLine(fmt.Sprintf(")"))
}

// AddSingleHeaderDependency adds a single-header dependency
func (cmake *CMakeFile) AddSingleHeaderDependency(SHA256, URL string) {
	headerName := filepath.Base(URL)
	cmake.writeSectionComment(headerName)
	dirname := "${CMAKE_BINARY_DIR}/.mkbuild/include"
	filename := dirname + "/" + headerName
	cmake.mkdirAll(dirname)
	cmake.download(filename, SHA256, URL)
	cmake.AddRequiredIncludeDir(dirname)
	cmake.RequireHeaderExists(headerName)
}

// AddSingleFileAsset adds a single-file asset to the build
func (cmake *CMakeFile) AddSingleFileAsset(SHA256, URL string) {
	assetName := filepath.Base(URL)
	cmake.writeSectionComment(assetName)
	dirname := "${CMAKE_BINARY_DIR}/.mkbuild/data"
	filename := dirname + "/" + assetName
	cmake.mkdirAll(dirname)
	cmake.download(filename, SHA256, URL)
}

// IfWIN32 allows you to generate WIN32 / !WIN32 specific code.
func (cmake *CMakeFile) IfWIN32(thenFunc func(), elseFunc func()) {
	cmake.writeEmptyLine()
	cmake.WriteLine("if((\"${WIN32}\"))")
	cmake.WithIndent("  ", thenFunc)
	if elseFunc != nil {
		cmake.WriteLine("else()")
		cmake.WithIndent("  ", elseFunc)
	}
	cmake.WriteLine("endif()")
}

// IfAPPLE allows you to generate APPLE / !APPLE specific code.
func (cmake *CMakeFile) IfAPPLE(thenFunc func(), elseFunc func()) {
	cmake.writeEmptyLine()
	cmake.WriteLine(`if(("${APPLE}"))`)
	cmake.WithIndent("  ", thenFunc)
	if elseFunc != nil {
		cmake.WriteLine("else()")
		cmake.WithIndent("  ", elseFunc)
	}
	cmake.WriteLine("endif()")
}

// if32bit allows you to generate 32 bit / 64 bit specific code. This
// function will configure cmake to fail if the bitsize is neither
// 32 not 64. That would be a very weird configuraton.
func (cmake *CMakeFile) if32bit(func32 func(), func64 func()) {
	cmake.WriteLine("if((\"${CMAKE_SIZEOF_VOID_P}\" EQUAL 4))")
	cmake.WithIndent("  ", func32)
	cmake.WriteLine("elseif((\"${CMAKE_SIZEOF_VOID_P}\" EQUAL 8))")
	cmake.WithIndent("  ", func64)
	cmake.WriteLine("else()")
	cmake.WithIndent("  ", func() {
		cmake.WriteLine("message(FATAL_ERROR \"Neither 32 not 64 bit\")")
	})
	cmake.WriteLine("endif()")
}

// Win32InstallPrebuilt installs a prebuilt Windows package.
func (cmake *CMakeFile) Win32InstallPrebuilt(pkg *prebuilt.Package) {
	cmake.DownloadAndExtractArchive(pkg.SHA256, pkg.URL)
	basedir := "${CMAKE_BINARY_DIR}/.mkbuild/download/" + pkg.Prefix + "/${MK_WIN32_ARCH}"
	includedirname := basedir + "/include"
	cmake.AddRequiredIncludeDir(includedirname)
	cmake.RequireHeaderExists(pkg.HeaderName)
	for _, lib := range pkg.Libs {
		libnameFull := basedir + "/lib/" + lib.Name
		cmake.RequireLibraryExists(libnameFull, lib.Func)
		cmake.AddRequiredLibrary(libnameFull)
	}
}

// DownloadAndExtractArchive downloads and extracts and archive
func (cmake *CMakeFile) DownloadAndExtractArchive(SHA256, URL string) {
	archiveName := filepath.Base(URL)
	cmake.writeSectionComment(archiveName)
	dirname := "${CMAKE_BINARY_DIR}/.mkbuild/download"
	filename := dirname + "/" + archiveName
	cmake.mkdirAll(dirname)
	cmake.download(filename, SHA256, URL)
	filepathname := dirname + "/" + archiveName
	cmake.untar(filepathname, dirname)
}

// FinalizeCompilerFlags finalizes compiler flags
func (cmake *CMakeFile) FinalizeCompilerFlags() {
	cmake.setRestrictiveCompilerFlags()
	cmake.prepareForCompilingTargets()
}

// Close writes CMakeLists.txt in the current directory.
func (cmake *CMakeFile) Close() {
	filename := "CMakeLists.txt"
	filep, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		log.WithError(err).Fatalf("os.Open failed for: %s", filename)
	}
	defer filep.Close()
	_, err = filep.WriteString(cmake.output.String())
	if err != nil {
		log.WithError(err).Fatalf("filep.WriteString failed for: %s", filename)
	}
	log.Infof("Written %s", filename)
}
